# 心累的C++

## C++中的四种Cast转换

1. const_cast: 用于将const变量转为非const（去除const属性）。
2. static_cast: 用于各种隐式转换，同一个继承体系中类型的转换，任意类型与空指针类型void*之间的转换。
3. dynamic_cast: 用于动态类型(运行时）转换。只能用于含有虚函数的类，用于类层次间的向下转化（从基类到派生类）。
4. reinterpret_cast: 可以用于任意类型的指针之间的转换，对转换的结果不做任何保证。

C风格的转换转化不够明确，不能进行错误检查，容易出错。

## C/C++指针和引用的区别

本质上，指针指向一块内存区域，而引用是一个对象的别名。

由此衍生出来的区别：
1. 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小。
2. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用。
3. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象。
4. 可以有const指针，但是没有const引用。
5. 指针可以有多级指针（**p），而引用至于一级。
6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变。
7. 指针和引用使用++运算符的意义不一样。
8. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。[理由及什么时候可以返回引用](https://blog.csdn.net/vc43vc/article/details/82927854)

## C++四个智能指针

为什么要使用智能指针：

智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，它将普通的指针封装成一个栈对象。当栈对象的生命周期结束后，会在析构函数释放掉申请的内存，从而防止内存泄漏。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

1. auto_ptr: 采用所有权模式，有潜在的内存崩溃风险，C++11已弃用。
2. unique_ptr: 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。
3. shared_ptr: shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。
4. weak_ptr: weak_ptr是一种不控制对象生命周期的智能指针, 它指向一个shared_ptr管理的对象。 进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr设计的目的是为配合 shared_ptr而引入的一种智能指针来协助 shared_ptr工作, 它只可以从一个 shared_ptr或另一个 weak_ptr对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。

## 智能指针shared_ptr的实现

核心要理解引用计数，什么时候销毁底层指针，还有赋值，拷贝构造时候的引用计数的变化，析构的时候要判断底层指针的引用计数为0了才能真正释放底层指针的内存。

引用计数需要保存在同一块内存，所有的shared_ptr对象的引用计数都指向这里。

注意不是只有在指针析构的时候才需要考虑计数是否为0，但指针指向另一个对象的时候，原对象对应的引用计数需要先减一，如果为0还需调用原对象的析构函数。

## 数组和指针的区别

1. 指针保存数据的地址，而数组保存数据本身。
2. 指针简介访问数据，数组直接访问数据。
3. 指针通常用于动态的数据结构，而数组通常用于固定数目且数据类型相同的元素。
4. 指针通常通过Malloc分配内存，free释放内存，而数组分配和删除是隐式的（栈变量）。
5. 指针通常指向匿名数据，操作匿名函数，数组自身即为数据名。

## 野指针是什么

野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针。

## 智能指针有没有内存泄漏的情况

当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效（计数均为2），从而导致内存泄漏。

## 上述问题如何解决

为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。

## 析构函数

析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。

如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。

类析构顺序：
1. 派生类本身的析构函数
2. 对象成员析构函数
3. 基类析构函数

## 为什么析构函数必须是虚函数

将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

## 为什么默认的析构函数不是虚函数

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

## 静态函数和虚函数的区别

静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。

## 重载和覆盖的区别

重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中。
重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写。

## 函数指针

函数指针是指向函数的指针变量。函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。

C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。

函数指针可以被用来调用函数和做函数的参数，比如回调函数。

## fork函数

Fork：创建一个和当前进程映像一样的进程。

成功调用fork()会创建一个新的进程，它几乎与调用fork()的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork()返回子进程的pid。如果出现错误，fork()返回一个负值。

最常见的fork()用法是创建一个新的进程，然后使用exec()载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。

## 说一说你理解的虚函数和多态

多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。


虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。

虚函数表的原理可参考：[C++虚函数和虚函数表原理](https://blog.csdn.net/u012630961/article/details/81226351)

## C++里是怎么定义常量的？常量存放在内存的哪个位置？

对于局部常量，存放在栈区；对于全局常量，编译期一般不分配内存，放在符号表中以提高访问效率；字面值常量，比如字符串，放在常量区。

## const修饰成员函数的目的是什么？

const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。

## 以下四行代码的区别是什么？ const char * arr = "123"; char * brr = "123"; const char crr[] = "123"; char drr[] = "123"

const char * arr = "123";

//字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样

char * brr = "123";

//字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改"123"的值

const char crr[] = "123";

//这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区

char drr[] = "123";

//字符串123保存在栈区，可以通过drr去修改

(这里也体现出了字符指针和字符数组本质上的不同，一个是直接指向字符串常量本身，一个是在栈上划分空间并复制)

## 请你来说一说隐式类型转换

首先，对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换，其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。

## 请你来说一说extern “C”

extern "C"是连接申明(linkage declaration), 被extern "C"修饰的变量和函数是按照C语言方式编译和连接的。

本质的原因在于C++编译和连接的方式与C不同，如果用C++的方式，则会找不到C文件编译生成的符号，因此当在C++中调用到C的代码时，我们需要用extern "C"{}来修饰这块代码。它们编译连接方式的不同也是C为什么不能重载函数的原因。

参考链接：[C++编译过的C代码为什么要用extern C](https://www.cnblogs.com/daocaorenblog/p/5310492.html)

## new/delete与malloc/free的区别是什么

首先，new/delete是C++的关键字，而malloc/free是C语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数。

## RTTI

RTTI(Run Time Type Identification)即通过运行时类型识别，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。

为什么会出现RTTI这一机制，这和C++语言本身有关系。和很多其他语言一样，C++是一种静态类型语言。其数据类型是在编译期就确定的，不能在运行时更改。然而由于面向对象程序设计中多态性的要求，C++中的指针或引用(Reference)本身的类型，可能与它实际代表(指向或引用)的类型并不一致。有时我们需要将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求。

RTTI提供了两个非常有用的操作符：typeid和dynamic_cast。

typeid操作符，返回指针和引用所指的实际类型；

dynamic_cast操作符，将基类类型的指针或引用安全地转换为其派生类类型的指针或引用。

VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info。

## 虚函数表具体是怎样实现运行时多态的?

子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的头部存放指向虚函数表的指针，通过该机制实现多态。

## C语言是怎么进行函数调用的？

每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。

## C语言参数压栈顺序？

从右到座

## 请你说说C++如何处理返回值？
对于非引用返回的都是临时变量，但是引用返回的不是临时变量而是这个引用。

## C++中拷贝赋值函数的形参能否进行值传递？

不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。

## 请你说说fork,wait,exec函数

父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1。