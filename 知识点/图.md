# 图的一些算法

## Dijkstra算法

## Floyd算法

Floyd算法是一种利用动态规划思想寻找给定的加权图中多源点之间最短路径的算法。

大致思路就是利用动态规划的思想，从权值矩阵出发，我们将其作为任意两点之间不经过其它任何点的最短路径。然后我们允许路径经过点1，更新距离矩阵。接着我们允许路径经过点2。由于我们是用前面更新过的矩阵来更新新矩阵的，即在允许经过点1的前提下考虑允许经过点2的情况，所以事实上更新后的矩阵描述的即使任意两点允许经过点1和点2的最短路径。我们重复这个过程n次，便能够得到一个多源最短路径矩阵。

更新对应的状态转移方程如下：
```Python
dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])
```

核心代码实现：
```Python
for k in range(n):
    for i in range(n):
        for j in range(n):
                d[i][j] = min(d[i][j], d[i][k] + d[k][j])
```

对应的时间复杂度为：O(n<sup>3</sup>)

对应的空间复杂度为：O(n<sup>2</sup>)

该算法允许加权图中有负权，但不能有负权回路（即负权环）。

通过引入一个后继节点矩阵，还可以记录两点间的最短路径。

相关资料参考：[Floyd-傻子也能看懂的弗洛伊德算法](https://www.cnblogs.com/wangyuliang/p/9216365.html)

## 判断图中是否有环

参考：[判断一个图是否有环](https://blog.csdn.net/u010040029/article/details/52861473)

### 无向图

#### （类似有向图的）拓扑排序

对于一个环1-2-3-4-1，每个节点的度都是2。基于此，我们可以有一下算法：
1. 求出图中所有顶点的度。
2. 删除图中所有度<=1的顶点以及与该顶点相关的边，把与这些边相关的顶点的度减一。
3. 如果还有度<=1的顶点重复步骤2。
4. 最后如果还存在未被删除的顶点，则表示有环；否则没有环。

时间复杂度为：O(E+V)

#### DFS

深度优先遍历该图，如果在遍历的过程中，发现某个节点有一条边指向已经访问过的节点，并且这个已访问过的节点不是当前节点的父节点（这里的父节点表示dfs遍历顺序中的父节点，即包括祖先节点），则表示存在环。

我们不能仅通过一个bool数组来标记节点是否被访问过，因为被访问过的节点并不一定是当前路径的节点，还可能是之前的路径（不同的递归方向）的节点。因此，我们可以将节点分为三种状态：白、灰、黑。

开始时所有节点都是白色，当开始访问某个节点时该节点变为灰色，当该节点的所有邻接点都访问完，该节点颜色变为黑色。那么我们的算法则为：如果遍历的过程中发现某个节点有一条边指向颜色为灰的节点，那么存在环。如果某个节点有一条边指向颜色为黑的节点，则不需要再重复计算该节点。

时间复杂度为：O(E+V)

### 有向图

#### Kahn算法

有向图的拓扑排序：
1. 计算图中所有点的入度，把入度为0的点加入栈。
2. 如果栈非空：
   1. 取出栈顶顶点a，输出该顶点值，删除该顶点。
   2. 从图中删除所有以a为起始点的边，如果删除的边的另一个顶点入度为0，则把它入栈。
3. 如果图中还存在顶点，则表示图中存在环；否则输出的顶点就是一个拓扑排序序列。

时间复杂度为：O(E+V)

无法输出环。

#### DFS

类似于无向图中DFS的算法。

#### 强连通分量

Tarjan算法和Kosaraju算法，有空再整理

[参考](https://www.cnblogs.com/reddest/p/5932153.html)
[图之强连通、强连通图、强连通分量 Tarjan算法](https://www.cnblogs.com/WTSRUVF/p/9300936.html)